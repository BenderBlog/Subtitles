[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1920
PlayResY: 1080

[Aegisub Project Garbage]
Audio File: Fast Inverse Square Root — A Quake III Algorithm-p8u_k2LIZyo.mp4
Video File: Fast Inverse Square Root — A Quake III Algorithm-p8u_k2LIZyo.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.500000
Scroll Position: 587
Active Line: 592
Video Position: 72180

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Comments,文泉驿等宽微米黑,56,&H0000FFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,8,10,10,40,1
Style: Chinese,文泉驿等宽微米黑,75,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,94,1
Style: Default,方正准圆简体,60,&H0000FFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,30,1
Style: Comments End,文泉驿等宽微米黑,56,&H0000FFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,4,10,10,35,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:03.77,Default,,0,0,0,,In 2005, game company id Software open source the engine
Dialogue: 0,0:00:03.77,0:00:05.88,Default,,0,0,0,,for their video game, Quake III Arena.
Dialogue: 0,0:00:05.88,0:00:08.91,Default,,0,0,0,,In that source code, fans of the game discovered a algorithm
Dialogue: 0,0:00:08.91,0:00:11.82,Default,,0,0,0,,that was so ingenious that quickly famous.
Dialogue: 0,0:00:11.82,0:00:16.05,Default,,0,0,0,,And the only thing the algorithm does is calculate the inverse of the square root.
Dialogue: 0,0:00:17.08,0:00:20.80,Default,,0,0,0,,If I have to write a piece of code that code calculate the inverse of the square root,
Dialogue: 0,0:00:20.80,0:00:22.25,Default,,0,0,0,,this is how I will do it.
Dialogue: 0,0:00:22.68,0:00:24.94,Default,,0,0,0,,Here, I am using the C Programming Language,
Dialogue: 0,0:00:24.94,0:00:27.68,Default,,0,0,0,,the same programming language used for the Quake III.
Dialogue: 0,0:00:27.68,0:00:31.25,Default,,0,0,0,,But to be fair, I wouldn't actually write the square root in there myself.
Dialogue: 0,0:00:31.80,0:00:35.20,Default,,0,0,0,,People work more closely with the C language or the CPU design,
Dialogue: 0,0:00:35.20,0:00:37.77,Default,,0,0,0,,have already figured out how to calculate the square root.
Dialogue: 0,0:00:37.77,0:00:41.02,Default,,0,0,0,,And provided the algorithm to us in a <math.h> file.
Dialogue: 0,0:00:41.02,0:00:44.08,Default,,0,0,0,,And we programmers can then just include in the program.
Dialogue: 0,0:00:44.71,0:00:48.74,Default,,0,0,0,,So what could possibly so interesting about the Quake III's algorithm?
Dialogue: 0,0:00:48.74,0:00:51.71,Default,,0,0,0,,How did id Software calculate inverse square root?
Dialogue: 0,0:00:55.88,0:00:58.74,Default,,0,0,0,,At first glance, it doesn't seems to make any scene.
Dialogue: 0,0:00:58.74,0:01:03.62,Default,,0,0,0,,Where does this number 0x5f3759df come from?
Dialogue: 0,0:01:03.62,0:01:06.65,Default,,0,0,0,,What does this have to do when taking square root?
Dialogue: 0,0:01:06.65,0:01:10.20,Default,,0,0,0,,And why there is a disgusting curse world in the second comment?
Dialogue: 0,0:01:10.20,0:01:12.31,Default,,0,0,0,,In this video, I will show you how was
Dialogue: 0,0:01:12.31,0:01:15.85,Default,,0,0,0,,some cool bit manipulation you can take in for the square root
Dialogue: 0,0:01:15.85,0:01:20.31,Default,,0,0,0,,and the algorithm that does this, bears the name, the Fast Inverse Square Root.
Dialogue: 0,0:01:23.28,0:01:25.82,Default,,0,0,0,,First of all, why does game engine want to calculate
Dialogue: 0,0:01:25.82,0:01:28.20,Default,,0,0,0,,the one divided by the square root of x?
Dialogue: 0,0:01:28.20,0:01:32.05,Default,,0,0,0,,If you want implement physics and lighting, or reflections in your game engine,
Dialogue: 0,0:01:32.05,0:01:36.20,Default,,0,0,0,,it helps when the vector you are calculating with are normalized with the length of 1.
Dialogue: 0,0:01:38.05,0:01:41.17,Default,,0,0,0,,Because other wise, your vector might be too short or too long
Dialogue: 0,0:01:41.17,0:01:43.74,Default,,0,0,0,,and when you do physics with them, things can go wrong.
Dialogue: 0,0:01:47.31,0:01:49.68,Default,,0,0,0,,As all of you know, the length of the vector is the
Dialogue: 0,0:01:49.68,0:01:52.62,Default,,0,0,0,,square root of the x squared plus y squared plus z squared.
Dialogue: 0,0:01:53.17,0:01:56.94,Default,,0,0,0,,If you don't happen to known this, I claimed you see this in two dimensions.
Dialogue: 0,0:01:56.94,0:01:58.82,Default,,0,0,0,,It's just the Pythagoras Theorem.
Dialogue: 0,0:01:59.40,0:02:02.28,Default,,0,0,0,,So if you want to normalize the vector's length to one,
Dialogue: 0,0:02:02.28,0:02:05.08,Default,,0,0,0,,we want to scale everything down by the length of the vector.
Dialogue: 0,0:02:05.37,0:02:08.85,Default,,0,0,0,,I mean, obviously, because if we divided the length of the vector
Dialogue: 0,0:02:08.85,0:02:11.94,Default,,0,0,0,,by the length of the vector, we obviously get one.
Dialogue: 0,0:02:12.42,0:02:16.17,Default,,0,0,0,,So all the left to do is to divide x, y, and z by the length.
Dialogue: 0,0:02:16.17,0:02:20.20,Default,,0,0,0,,Or similarly, multiplied by one divided by the length.
Dialogue: 0,0:02:20.20,0:02:22.28,Default,,0,0,0,,You might already see where this is going.
Dialogue: 0,0:02:25.28,0:02:28.74,Default,,0,0,0,,Calculate the x squared plus y squared plus z squared is easy,
Dialogue: 0,0:02:28.74,0:02:31.37,Default,,0,0,0,,and more importantly, really fast.
Dialogue: 0,0:02:31.37,0:02:36.00,Default,,0,0,0,,In code, you would implement this: x*x+y*y+z*z.
Dialogue: 0,0:02:36.00,0:02:39.02,Default,,0,0,0,,And all it did is just three multiplications summed up.
Dialogue: 0,0:02:39.85,0:02:43.00,Default,,0,0,0,,Additions and the multiplications are common operations
Dialogue: 0,0:02:43.00,0:02:45.20,Default,,0,0,0,,and have been designed to be really fast.
Dialogue: 0,0:02:45.94,0:02:49.28,Default,,0,0,0,,The square root, on the other hand, is a terribly slow operations.
Dialogue: 0,0:02:49.28,0:02:51.00,Default,,0,0,0,,And divisions is not much better.
Dialogue: 0,0:02:51.42,0:02:54.77,Default,,0,0,0,,This is not good if we have several thousands of surfaces,
Dialogue: 0,0:02:54.77,0:02:57.48,Default,,0,0,0,,where each of the vectors needs to be normalized.
Dialogue: 0,0:02:58.05,0:03:03.02,Default,,0,0,0,,But this also means that in here, we have an opportunity for speed improvements.
Dialogue: 0,0:03:03.02,0:03:07.68,Default,,0,0,0,,If we can find, even just the approximation of one divided by the square root of the x,
Dialogue: 0,0:03:07.68,0:03:11.42,Default,,0,0,0,,as long as it's fast, we can save precious time.
Dialogue: 0,0:03:11.42,0:03:14.80,Default,,0,0,0,,The Fast Inverse Square Root is such a approximation,
Dialogue: 0,0:03:14.80,0:03:19.65,Default,,0,0,0,,with only an error of almost 1%, but been three times as fast.
Dialogue: 0,0:03:22.02,0:03:26.45,Default,,0,0,0,,Looking at the code again, we can see that the beginning is pretty harmless.
Dialogue: 0,0:03:26.45,0:03:29.65,Default,,0,0,0,,We are given a number called 'number' as input.
Dialogue: 0,0:03:29.65,0:03:32.51,Default,,0,0,0,,The number where suppose to take the inverse square root off.
Dialogue: 0,0:03:33.05,0:03:36.77,Default,,0,0,0,,First, with the variable i, we declare 32-bit number.
Dialogue: 0,0:03:37.62,0:03:42.31,Default,,0,0,0,,Then, we declare two 32-bit decimal numbers, x2 and y.
Dialogue: 0,0:03:42.77,0:03:47.51,Default,,0,0,0,,And then we store 1.5 into the variable, with the obvious name, threehalfs.
Dialogue: 0,0:03:48.88,0:03:52.54,Default,,0,0,0,,Next to the line is simply copy half of it and put it into the x2,
Dialogue: 0,0:03:52.54,0:03:54.25,Default,,0,0,0,,and the whole then put into the y.
Dialogue: 0,0:03:54.25,0:03:56.74,Default,,0,0,0,,But it is after that the magic happens.
Dialogue: 0,0:03:57.25,0:03:59.05,Default,,0,0,0,,Take a moment to look at it again.
Dialogue: 0,0:04:01.80,0:04:05.37,Default,,0,0,0,,Well, the longer you look at it, the less it make scene.
Dialogue: 0,0:04:05.37,0:04:08.02,Default,,0,0,0,,And that comment on the right aren't really help either.
Dialogue: 0,0:04:08.65,0:04:12.17,Default,,0,0,0,,But they do hit that there are three steps on the algorithm.
Dialogue: 0,0:04:12.17,0:04:16.74,Default,,0,0,0,,Puzzling together these three steps, they will show us the brilliancy of this algorithm.
Dialogue: 0,0:04:18.20,0:04:22.94,Default,,0,0,0,,But before we start with these three steps, let's first take a look at binary numbers.
Dialogue: 0,0:04:22.94,0:04:26.40,Default,,0,0,0,,They said that in the first line, we declared 32-bit integer.
Dialogue: 0,0:04:26.40,0:04:29.31,Default,,0,0,0,,In the C Programming Language, this is called 'long'.
Dialogue: 0,0:04:29.31,0:04:33.54,Default,,0,0,0,,That means we have 32 bits and we can represent numbers with it.
Dialogue: 0,0:04:33.54,0:04:36.05,Default,,0,0,0,,But I think you all know how to do with that.
Dialogue: 0,0:04:36.05,0:04:41.00,Default,,0,0,0,,This is one, two, three, four, and so on. Up to around billion.
Dialogue: 0,0:04:41.91,0:04:46.85,Default,,0,0,0,,But in the next line, we declare two decimal numbers. In C, called a float.
Dialogue: 0,0:04:46.85,0:04:51.82,Default,,0,0,0,,Again, we given 32 bits, and we have to represent the decimal numbers with it.
Dialogue: 0,0:04:52.28,0:04:53.60,Default,,0,0,0,,How would you do that?
Dialogue: 0,0:04:54.05,0:04:56.54,Default,,0,0,0,,If you and I were designing decimal numbers,
Dialogue: 0,0:04:56.54,0:04:58.68,Default,,0,0,0,,this is probably one way we will do it.
Dialogue: 0,0:04:59.17,0:05:01.08,Default,,0,0,0,,Just put the decimal point in the middle.
Dialogue: 0,0:05:01.54,0:05:04.60,Default,,0,0,0,,In front of the decimal point, we count the usual way.
Dialogue: 0,0:05:04.60,0:05:07.42,Default,,0,0,0,,One, two, three, four... and so on.
Dialogue: 0,0:05:07.42,0:05:10.68,Default,,0,0,0,,And after the decimal point, there's no surprise, it is either.
Dialogue: 0,0:05:11.02,0:05:16.02,Default,,0,0,0,,Just remind yourself, this is binary. So instead of tenth, hundreds, thousands,
Dialogue: 0,0:05:16.02,0:05:20.48,Default,,0,0,0,,we have halves, fourths, eights, sixteens, and any combinations of them.
Dialogue: 0,0:05:20.48,0:05:25.22,Default,,0,0,0,,Like a halves and a fourths give you three fourths, also known as 0.75.
Dialogue: 0,0:05:26.37,0:05:28.60,Default,,0,0,0,,But this idea is actually terrible.
Dialogue: 0,0:05:28.60,0:05:31.77,Default,,0,0,0,,We decimate the range the number that can represent.
Dialogue: 0,0:05:31.77,0:05:35.51,Default,,0,0,0,,Before we could represent numbers to around two billion,
Dialogue: 0,0:05:35.51,0:05:38.25,Default,,0,0,0,,now only to about 32 thousands.
Dialogue: 0,0:05:39.00,0:05:41.25,Default,,0,0,0,,Luckily, people much smarter than us
Dialogue: 0,0:05:41.25,0:05:44.05,Default,,0,0,0,,have find a better way to make use of the 32 bits.
Dialogue: 0,0:05:44.57,0:05:47.65,Default,,0,0,0,,They took inspiration from the scientific notation.
Dialogue: 0,0:05:48.77,0:05:51.57,Default,,0,0,0,,The same way, we can systematically represent numbers,
Dialogue: 0,0:05:51.57,0:05:55.02,Default,,0,0,0,,like 23,000 as 2.3 times 10 to the 4.
Dialogue: 0,0:05:55.02,0:05:59.45,Default,,0,0,0,,And 0.0034 as 3.4 times 10 to the minus 3.
Dialogue: 0,0:05:59.85,0:06:02.48,Default,,0,0,0,,We can also represent them in a binary system.
Dialogue: 0,0:06:02.48,0:06:09.05,Default,,0,0,0,,With here for example, 11000(bin) could for an example be 1.1 times 2 to the 4.
Dialogue: 0,0:06:10.54,0:06:15.48,Default,,0,0,0,,The standard that come up with takes the name IEEE 754.
Dialogue: 0,0:06:17.48,0:06:21.02,Default,,0,0,0,,IEEE Standard 754 defines the following:
Dialogue: 0,0:06:21.32,0:06:23.77,Default,,0,0,0,,We are as usual, given 32 bits.
Dialogue: 0,0:06:24.25,0:06:26.27,Default,,0,0,0,,The first bit is a sign bit.
Dialogue: 0,0:06:26.27,0:06:28.35,Default,,0,0,0,,If it's zero, the number is positive.
Dialogue: 0,0:06:28.35,0:06:30.35,Default,,0,0,0,,If it's one, the number is negative.
Dialogue: 0,0:06:30.87,0:06:35.52,Default,,0,0,0,,But the numbers in Quake III provides the fast inverse square root, are always positive.
Dialogue: 0,0:06:35.90,0:06:37.80,Default,,0,0,0,,I mean, obviously they are positive.
Dialogue: 0,0:06:37.80,0:06:41.42,Default,,0,0,0,,If we will have to calculate 1 divided by the square root of -5,
Dialogue: 0,0:06:41.42,0:06:43.17,Default,,0,0,0,,something definitely is gonna wrong.
Dialogue: 0,0:06:43.77,0:06:48.27,Default,,0,0,0,,So for the rest of this video, we ignore the sign bit, as this is always zero.
Dialogue: 0,0:06:49.90,0:06:53.05,Default,,0,0,0,,Then, the next 8 bits define the exponent.
Dialogue: 0,0:06:53.05,0:06:58.15,Default,,0,0,0,,That means 2 to the 1, 2 to the 2, 2 to the 3, 2 to the 4, and so on.
Dialogue: 0,0:06:58.15,0:07:02.35,Default,,0,0,0,,With 8 bits, we can represent numbers between 0 and 255.
Dialogue: 0,0:07:03.20,0:07:07.27,Default,,0,0,0,,But that's not exactly what we need, we also want negative exponent.
Dialogue: 0,0:07:08.20,0:07:12.07,Default,,0,0,0,,This is why everything is actually shifted down by 127.
Dialogue: 0,0:07:13.25,0:07:17.75,Default,,0,0,0,,So instead of 2 to the 4, we actually have 2 to the 4 minus 127.
Dialogue: 0,0:07:18.45,0:07:23.07,Default,,0,0,0,,If we actually want exponent to be four, the bits need to be set 131.
Dialogue: 0,0:07:23.60,0:07:28.17,Default,,0,0,0,,Because 131-127=4.
Dialogue: 0,0:07:29.82,0:07:32.50,Default,,0,0,0,,The last 23 bits are the mantissa.
Dialogue: 0,0:07:33.07,0:07:37.32,Default,,0,0,0,,As usually in scientific notation, we want to denote one digit.
Dialogue: 0,0:07:37.32,0:07:40.55,Default,,0,0,0,,followed by the comma, followed by the decimal places.
Dialogue: 0,0:07:41.07,0:07:47.37,Default,,0,0,0,,But with 23 bits, we can represent numbers from 0 to, but not including, 2 to the 23.
Dialogue: 0,0:07:48.00,0:07:50.40,Default,,0,0,0,,Again, that is not exactly what we need.
Dialogue: 0,0:07:50.75,0:07:54.82,Default,,0,0,0,,For scientific notation, we need an mantissa go to from 1 to 10.
Dialogue: 0,0:07:54.82,0:07:58.50,Default,,0,0,0,,Or in binary scientific notation, to go from 1 to 2.
Dialogue: 0,0:08:00.15,0:08:03.20,Default,,0,0,0,,So we can do something that we've already done before.
Dialogue: 0,0:08:03.20,0:08:05.37,Default,,0,0,0,,Put a comma after the first bit.
Dialogue: 0,0:08:05.37,0:08:08.35,Default,,0,0,0,,This automatically gives us numbers from 1 to 2.
Dialogue: 0,0:08:09.17,0:08:11.25,Default,,0,0,0,,But this naive approach is wasteful.
Dialogue: 0,0:08:11.62,0:08:15.32,Default,,0,0,0,,You see, the people that design the standard 754 realize
Dialogue: 0,0:08:15.32,0:08:19.47,Default,,0,0,0,,that in binary, something happens, that happens in no other base.
Dialogue: 0,0:08:23.97,0:08:25.50,Default,,0,0,0,,Look at the first digit.
Dialogue: 0,0:08:26.02,0:08:31.00,Default,,0,0,0,,In scientific notation, the first digit is by definition, always non-zero.
Dialogue: 0,0:08:31.45,0:08:36.00,Default,,0,0,0,,But in binary, there is only one digit that is not zero-- one!
Dialogue: 0,0:08:36.65,0:08:41.42,Default,,0,0,0,,And if we know that the first digit will be always be one, there's no need to store it.
Dialogue: 0,0:08:41.85,0:08:46.40,Default,,0,0,0,,Thus, we can save one bit. And moving the comma one digit to the left.
Dialogue: 0,0:08:46.40,0:08:49.45,Default,,0,0,0,,And fixing an extra one in the number it presents.
Dialogue: 0,0:08:49.77,0:08:52.45,Default,,0,0,0,,Now our mantissa is between one and two.
Dialogue: 0,0:08:53.25,0:08:57.80,Default,,0,0,0,,Even though the 23 bits gave us numbers between zero and two to the 23.
Dialogue: 0,0:08:57.80,0:09:01.22,Default,,0,0,0,,We scale them down to get numbers between zero and one.
Dialogue: 0,0:09:01.22,0:09:05.20,Default,,0,0,0,,And then we add the extra one, to get numbers between one and two.
Dialogue: 0,0:09:06.87,0:09:11.55,Default,,0,0,0,,And this already is the main part of the IEEE standard 754.
Dialogue: 0,0:09:11.55,0:09:14.35,Default,,0,0,0,,But just, this is so called "normalised numbers".
Dialogue: 0,0:09:14.70,0:09:16.32,Default,,0,0,0,,The informed viewer known that
Dialogue: 0,0:09:16.32,0:09:20.56,Default,,0,0,0,,this standard is also included denormalised numbers, NaN numbers,
Dialogue: 0,0:09:20.56,0:09:22.92,Default,,0,0,0,,infinities and two zeroes.
Dialogue: 0,0:09:23.16,0:09:24.53,Default,,0,0,0,,But we won't go into those.
Dialogue: 0,0:09:24.68,0:09:29.09,Default,,0,0,0,,Because in Quake III, it just happens that these are never be input into our algorithm.
Dialogue: 0,0:09:29.50,0:09:32.56,Default,,0,0,0,,Other wise, something definitely has gone wrong anyway.
Dialogue: 0,0:09:32.85,0:09:37.25,Default,,0,0,0,,It is no point should a game engine have to normalize a vector with infinite length.
Dialogue: 0,0:09:38.44,0:09:40.93,Default,,0,0,0,,For this algorithm, and for the rest of this video,
Dialogue: 0,0:09:40.93,0:09:45.72,Default,,0,0,0,,it would be useful to think the mantissa and exponent are binary numbers they are.
Dialogue: 0,0:09:46.17,0:09:50.66,Default,,0,0,0,,If we are given two numbers, one being the mantissa and one being the exponent.
Dialogue: 0,0:09:50.66,0:09:53.17,Default,,0,0,0,,23 bits and 8 bits respectively.
Dialogue: 0,0:09:53.17,0:09:55.18,Default,,0,0,0,,We can get the bit representation with (them).
Dialogue: 0,0:09:55.44,0:09:58.97,Default,,0,0,0,,2 to the 23, times E, plus M, if you think about it.
Dialogue: 0,0:09:59.68,0:10:05.02,Default,,0,0,0,,Because multiplying E by 2 to the 23 just shift E by 23 digit.
Dialogue: 0,0:10:06.21,0:10:08.24,Default,,0,0,0,,So that's how one could write the bits.
Dialogue: 0,0:10:08.56,0:10:12.21,Default,,0,0,0,,But we get the actual number behind the bits with this formula.
Dialogue: 0,0:10:12.94,0:10:14.69,Default,,0,0,0,,This should seems familiar to you.
Dialogue: 0,0:10:15.01,0:10:19.14,Default,,0,0,0,,Here we have the exponent with 127 subtracted from it.
Dialogue: 0,0:10:19.36,0:10:22.61,Default,,0,0,0,,And here we have the mantissa, with an extra one in front.
Dialogue: 0,0:10:24.13,0:10:26.24,Default,,0,0,0,,But now, something completely different.
Dialogue: 0,0:10:26.72,0:10:31.04,Default,,0,0,0,,For no obvious reason at all, let's take the logarithm out of that expression.
Dialogue: 0,0:10:31.57,0:10:35.61,Default,,0,0,0,,Since we're doing computer science here, we take the logarithm base two.
Dialogue: 0,0:10:36.12,0:10:38.28,Default,,0,0,0,,We simplify as much we can.
Dialogue: 0,0:10:38.57,0:10:39.78,Default,,0,0,0,,Take out the exponent.
Dialogue: 0,0:10:40.01,0:10:41.13,Default,,0,0,0,,But then, we get stuck.
Dialogue: 0,0:10:41.98,0:10:44.05,Default,,0,0,0,,But not so the creators of Quake.
Dialogue: 0,0:10:44.36,0:10:47.88,Default,,0,0,0,,Developer Gary Tarolli knew the trick to get the rid of the logarithm.
Dialogue: 0,0:10:48.65,0:10:52.74,Default,,0,0,0,,You see, the trick is the approximation to log of 1 plus x.
Dialogue: 0,0:10:53.06,0:10:58.40,Default,,0,0,0,,For small value of x, log of 1 plus x is approximately equal to x.
Dialogue: 0,0:10:58.85,0:11:02.09,Default,,0,0,0,,If you think about it, this approximation is actually correct.
Dialogue: 0,0:11:02.28,0:11:05.02,Default,,0,0,0,,For x equals 0, and x equals 1.
Dialogue: 0,0:11:05.76,0:11:08.18,Default,,0,0,0,,But we add additional term, μ(mu would be written as follow).
Dialogue: 0,0:11:08.76,0:11:11.13,Default,,0,0,0,,This correction term can be chosen freely.
Dialogue: 0,0:11:11.53,0:11:16.36,Default,,0,0,0,,Again, with mu equals to 0, this approximation is correct at 0 and 1.
Dialogue: 0,0:11:16.62,0:11:19.26,Default,,0,0,0,,But it turns out that set mu in this number,
Dialogue: 0,0:11:19.26,0:11:23.34,Default,,0,0,0,,gives the smallest error on average, for numbers between 0 and 1.
Dialogue: 0,0:11:24.86,0:11:27.84,Default,,0,0,0,,So going back to our formula, we apply our tricks.
Dialogue: 0,0:11:27.84,0:11:32.84,Default,,0,0,0,,As M divided by 2 to the 23, it is indeed a value between 0 and 1.
Dialogue: 0,0:11:34.14,0:11:39.41,Default,,0,0,0,,We rearrange a little bit more and we finally see why we did all those calculations.
Dialogue: 0,0:11:40.26,0:11:43.26,Default,,0,0,0,,M plus E time 2 to the 23 appears.
Dialogue: 0,0:11:43.72,0:11:45.54,Default,,0,0,0,,That's our bits representation.
Dialogue: 0,0:11:46.62,0:11:49.02,Default,,0,0,0,,So let's think about we just said,
Dialogue: 0,0:11:49.42,0:11:53.88,Default,,0,0,0,,We apply the logarithm to our formula, and got the bit representation.
Dialogue: 0,0:11:53.88,0:11:56.29,Default,,0,0,0,,Just scaled and shifted by some constants.
Dialogue: 0,0:11:56.77,0:12:01.02,Default,,0,0,0,,So in some sense, the bit representation of a number is its own logarithm.
Dialogue: 0,0:12:01.58,0:12:04.30,Default,,0,0,0,,Armed with this knowledge, we can finally start
Dialogue: 0,0:12:04.30,0:12:07.09,Default,,0,0,0,,with the three steps of the Fast Inverse Square Root.
Dialogue: 0,0:12:16.65,0:12:18.96,Default,,0,0,0,,The first step is actually not complicated.
Dialogue: 0,0:12:18.96,0:12:22.09,Default,,0,0,0,,It's just looks complicated because of the memory address trickery.
Dialogue: 0,0:12:22.64,0:12:27.21,Default,,0,0,0,,So we store our number into y, and now we want to do cool bit manipulation tricks.
Dialogue: 0,0:12:27.60,0:12:32.10,Default,,0,0,0,,Floats, unfortunately, don't come with a tool which we need to do bit manipulation.
Dialogue: 0,0:12:32.72,0:12:35.45,Default,,0,0,0,,The reason you cannot do bit manipulation on floats,
Dialogue: 0,0:12:35.45,0:12:37.48,Default,,0,0,0,,is that they were never designed to do so.
Dialogue: 0,0:12:38.00,0:12:41.82,Default,,0,0,0,,Floats are inherently tied to IEEE standard 754.
Dialogue: 0,0:12:42.42,0:12:46.21,Default,,0,0,0,,Longs, on the other hand, were designed to do bits manipulations on them.
Dialogue: 0,0:12:46.66,0:12:48.10,Default,,0,0,0,,For example, here's one tricks.
Dialogue: 0,0:12:51.42,0:12:53.80,Default,,0,0,0,,Bits shifting along to the left, doubles it.
Dialogue: 0,0:12:55.89,0:12:58.18,Default,,0,0,0,,And bits then shifting to the right, halves it.
Dialogue: 0,0:12:59.18,0:13:02.65,Default,,0,0,0,,And yes, if your numbers are odd, you would end up rounding.
Dialogue: 0,0:13:05.34,0:13:08.13,Default,,0,0,0,,But hey, we're willing to accept such inaccuracy,
Dialogue: 0,0:13:08.13,0:13:10.72,Default,,0,0,0,,as long as it means that this algorithm is fast.
Dialogue: 0,0:13:12.38,0:13:15.12,Default,,0,0,0,,C, as pretty much all other programming languages do,
Dialogue: 0,0:13:15.12,0:13:18.29,Default,,0,0,0,,provides a way to converts from a float to a long.
Dialogue: 0,0:13:18.76,0:13:21.66,Default,,0,0,0,,This conversion does what most programmers needed to do.
Dialogue: 0,0:13:21.66,0:13:26.28,Default,,0,0,0,,namely convert from a decimal number to an ordinary integer as best it can do.
Dialogue: 0,0:13:26.72,0:13:32.53,Default,,0,0,0,,So if we can get a float, like 3.33, it converse to an integer, in this case, 3.
Dialogue: 0,0:13:33.04,0:13:35.33,Default,,0,0,0,,But this is not the conversion we need here.
Dialogue: 0,0:13:35.70,0:13:39.14,Default,,0,0,0,,First of all, we don't care about the result in integer number.
Dialogue: 0,0:13:39.14,0:13:41.40,Default,,0,0,0,,We want to somehow, keep our float.
Dialogue: 0,0:13:41.86,0:13:45.37,Default,,0,0,0,,And secondly, the bits that are lie behind numbers are messed up.
Dialogue: 0,0:13:45.92,0:13:48.52,Default,,0,0,0,,We don't want this conversion to mess with this bits.
Dialogue: 0,0:13:49.00,0:13:53.76,Default,,0,0,0,,The only thing we want to do is to put the bits, one to one, into a long.
Dialogue: 0,0:13:56.94,0:14:01.28,Default,,0,0,0,,The way you achieve this, is to convert the memory address, not the number.
Dialogue: 0,0:14:02.90,0:14:07.24,Default,,0,0,0,,First, we get the address of y, this is the address of the float.
Dialogue: 0,0:14:07.90,0:14:12.16,Default,,0,0,0,,Then you convert the address from a float address into a long address.
Dialogue: 0,0:14:13.36,0:14:16.57,Default,,0,0,0,,The address itself doesn't change, but C now thinks
Dialogue: 0,0:14:16.57,0:14:19.40,Default,,0,0,0,,the number living at the address is now a long.
Dialogue: 0,0:14:20.00,0:14:22.80,Default,,0,0,0,,So then, you read what's written at that address.
Dialogue: 0,0:14:23.00,0:14:25.90,Default,,0,0,0,,Because C now think that this is a address of a long,
Dialogue: 0,0:14:25.90,0:14:29.69,Default,,0,0,0,,it will read the number at the address, as it were a long.
Dialogue: 0,0:14:30.42,0:14:34.86,Default,,0,0,0,,Like this, we tricked C by lifting the conversion away from the number itself
Dialogue: 0,0:14:34.86,0:14:36.86,Default,,0,0,0,,to the address of the number.
Dialogue: 0,0:14:37.86,0:14:40.76,Default,,0,0,0,,And that's how we get the bits of the number into i.
Dialogue: 0,0:14:41.28,0:14:44.24,Default,,0,0,0,,I donno know what else to say, that's just how C works,
Dialogue: 0,0:14:44.24,0:14:45.90,Default,,0,0,0,,so let's just go to the next step.
Dialogue: 0,0:14:51.84,0:14:54.78,Default,,0,0,0,,The intuition behind the second step is the following.
Dialogue: 0,0:14:55.18,0:14:58.53,Default,,0,0,0,,Remind yourself, bit shifting a number to the left doubles it.
Dialogue: 0,0:15:00.33,0:15:02.44,Default,,0,0,0,,And shifting to the right, halves it.
Dialogue: 0,0:15:03.45,0:15:06.73,Default,,0,0,0,,But what would happen if we did something like this to an exponent？
Dialogue: 0,0:15:07.54,0:15:10.06,Default,,0,0,0,,Doubling an exponent squares the number,
Dialogue: 0,0:15:10.06,0:15:12.84,Default,,0,0,0,,and halving the exponent gives us an square root.
Dialogue: 0,0:15:13.24,0:15:17.85,Default,,0,0,0,,But now also negating the exponent, give us 1 divided by the square root of x.
Dialogue: 0,0:15:17.85,0:15:19.34,Default,,0,0,0,,This is exactly what we need.
Dialogue: 0,0:15:20.53,0:15:23.01,Default,,0,0,0,,So let's remind ourselves what our goals is here.
Dialogue: 0,0:15:23.33,0:15:25.24,Default,,0,0,0,,We have our numbers stored into y,
Dialogue: 0,0:15:25.24,0:15:28.52,Default,,0,0,0,,and our goal was to calculate the 1 divided by the square root of y.
Dialogue: 0,0:15:28.92,0:15:33.32,Default,,0,0,0,,As our already said, calculate this directly is too hard and too expensive.
Dialogue: 0,0:15:34.00,0:15:36.00,Default,,0,0,0,,But we extracted the bits from y.
Dialogue: 0,0:15:36.00,0:15:39.18,Default,,0,0,0,,And we have seen with the IEEE standard 754,
Dialogue: 0,0:15:39.18,0:15:42.73,Default,,0,0,0,,that the bits of the number are, in some sense, its own logarithm.
Dialogue: 0,0:15:43.40,0:15:48.33,Default,,0,0,0,,That means, in i, we have stored the log of y, up to some scaling and shifting.
Dialogue: 0,0:15:49.00,0:15:53.01,Default,,0,0,0,,I claim that the problem will become way easier if we work with log.
Dialogue: 0,0:15:53.60,0:15:57.37,Default,,0,0,0,,Instead of trying so hard to calculate the 1 divided by the square root of y,
Dialogue: 0,0:15:57.37,0:16:00.89,Default,,0,0,0,,we instead calculate log of 1 divided by the square root of y.
Dialogue: 0,0:16:01.68,0:16:05.13,Default,,0,0,0,,We rewrite this to log of y to the power of minus half.
Dialogue: 0,0:16:05.13,0:16:07.00,Default,,0,0,0,,So we can take the exponent.
Dialogue: 0,0:16:07.64,0:16:10.26,Default,,0,0,0,,Calculate this is stupidly easy.
Dialogue: 0,0:16:10.64,0:16:13.40,Default,,0,0,0,,You might think "Oh no! We have a division in here.
Dialogue: 0,0:16:13.40,0:16:16.01,Default,,0,0,0,,Didn't you said that in the beginning, that division are slow?"
Dialogue: 0,0:16:16.41,0:16:19.45,Default,,0,0,0,,Oh yes, but remember that we can do bit shifts now.
Dialogue: 0,0:16:19.88,0:16:23.40,Default,,0,0,0,,Instead of dividing by 2, we just bit shift once to the right.
Dialogue: 0,0:16:23.85,0:16:28.36,Default,,0,0,0,,This already explains why we do minus i, bit shift once to the right.
Dialogue: 0,0:16:29.08,0:16:33.25,Default,,0,0,0,,But why this number 0x5f3759df here again?
Dialogue: 0,0:16:33.69,0:16:37.21,Default,,0,0,0,,Well, because our algorithm is actually scales and shifts it.
Dialogue: 0,0:16:37.48,0:16:40.41,Default,,0,0,0,,So let's calculate it and understand where it comes from.
Dialogue: 0,0:16:41.00,0:16:43.02,Default,,0,0,0,,Let Γ (gamma would be written at below) be our solution.
Dialogue: 0,0:16:43.64,0:16:48.41,Default,,0,0,0,,Then we knew, the log of gamma equals to the log of y to the power of minus half,
Dialogue: 0,0:16:48.80,0:16:51.44,Default,,0,0,0,,which equals to minus half times log of y.
Dialogue: 0,0:16:52.12,0:16:55.72,Default,,0,0,0,,Now we replace the logarithm with the bit representation.
Dialogue: 0,0:17:01.94,0:17:04.38,Default,,0,0,0,,And then we just solve for the bits of gamma.
Dialogue: 0,0:17:04.82,0:17:07.53,Default,,0,0,0,,I spared the details but this is the result.
Dialogue: 0,0:17:09.33,0:17:12.88,Default,,0,0,0,,The magic number turns out, to be the remnants of the error in terms of mu,
Dialogue: 0,0:17:12.88,0:17:14.88,Default,,0,0,0,,the scaling factor and the shifting.
Dialogue: 0,0:17:16.81,0:17:19.45,Default,,0,0,0,,Now we have the bits of the solution
Dialogue: 0,0:17:19.45,0:17:22.18,Default,,0,0,0,,and we can just reverse this step from the evil hack
Dialogue: 0,0:17:22.18,0:17:25.26,Default,,0,0,0,,to get back to the actual solution from those bits.
Dialogue: 0,0:17:25.81,0:17:30.20,Default,,0,0,0,,Well... actually, that isn't exact solution, just an approximation.
Dialogue: 0,0:17:30.53,0:17:32.90,Default,,0,0,0,,This is why we need the third step.
Dialogue: 0,0:17:41.50,0:17:44.89,Default,,0,0,0,,After the previous step, we have a pretty decent approximation.
Dialogue: 0,0:17:44.89,0:17:47.34,Default,,0,0,0,,But we did pick up some error terms here and there.
Dialogue: 0,0:17:47.86,0:17:49.89,Default,,0,0,0,,But thanks to Newton's Method, we can make
Dialogue: 0,0:17:49.89,0:17:52.61,Default,,0,0,0,,the really good approximation out of the decent one.
Dialogue: 0,0:17:53.21,0:17:56.89,Default,,0,0,0,,Newton's Method is a technique that find the root of a given function.
Dialogue: 0,0:17:57.09,0:18:00.21,Default,,0,0,0,,Meaning it finds a x, for which f(x) equals zero.
Dialogue: 0,0:18:00.68,0:18:04.89,Default,,0,0,0,,It does so by taking a approximation that returning a better approximation.
Dialogue: 0,0:18:05.09,0:18:09.72,Default,,0,0,0,,Usually, you repeat this process until you close enough to the actual solution.
Dialogue: 0,0:18:09.72,0:18:14.40,Default,,0,0,0,,But it turns out that here we are already close enough to the actual solution.
Dialogue: 0,0:18:14.40,0:18:18.53,Default,,0,0,0,,that one iteration suffices to get an error of 1 percent.
Dialogue: 0,0:18:21.82,0:18:26.33,Default,,0,0,0,,The only things Newton's Method needs is the function and its derivative.
Dialogue: 0,0:18:26.33,0:18:29.89,Default,,0,0,0,,And what Newton's Method does is that it takes a x value,
Dialogue: 0,0:18:29.89,0:18:33.66,Default,,0,0,0,,and it tries to guess by how much it is off from being the roots.
Dialogue: 0,0:18:34.36,0:18:38.16,Default,,0,0,0,,It does so by calculating f(x) and its derivative.
Dialogue: 0,0:18:41.76,0:18:46.80,Default,,0,0,0,,We can write f(x) as a y, and the derivative as dy over dx.
Dialogue: 0,0:18:49.88,0:18:54.20,Default,,0,0,0,,We have the ratio between y and x offset, and y itself.
Dialogue: 0,0:18:54.50,0:18:58.29,Default,,0,0,0,,So to get the x offset, we just divide y by the ratio.
Dialogue: 0,0:19:04.22,0:19:07.78,Default,,0,0,0,,So then we simply subtract the offset to get the new x.
Dialogue: 0,0:19:10.29,0:19:13.44,Default,,0,0,0,,The informed viewer can now verify that the last line is
Dialogue: 0,0:19:13.44,0:19:16.24,Default,,0,0,0,,Newton Iteration that apply to the function.
Dialogue: 0,0:19:16.45,0:19:20.22,Default,,0,0,0,,f(y) equals to 1 divided by the y squared minus x.
Dialogue: 0,0:19:20.84,0:19:23.84,Default,,0,0,0,,Notice that the y being the root of the function
Dialogue: 0,0:19:23.84,0:19:27.09,Default,,0,0,0,,is equivalent to y being in the inverse square root of x.
Dialogue: 0,0:19:30.93,0:19:34.06,Default,,0,0,0,,I really encourage you to verify the last line of the code.
Dialogue: 0,0:19:34.06,0:19:38.10,Default,,0,0,0,,Since it is really surprising that even though both the function
Dialogue: 0,0:19:38.10,0:19:42.16,Default,,0,0,0,,and Newton's Method have division in them, the code does not.
Dialogue: 0,0:19:42.16,0:19:45.58,Default,,0,0,0,,Which means the algorithm is, and stays stays fast.
Dialogue: 0,0:19:47.45,0:19:50.54,Default,,0,0,0,,Now we finally understand the Fast Inverse Square Root.
Dialogue: 0,0:19:50.54,0:19:54.73,Default,,0,0,0,,It only took us the knowledge of IEEE 754,
Dialogue: 0,0:19:54.73,0:19:57.56,Default,,0,0,0,,an trick to outsmart the C Programming Language,
Dialogue: 0,0:19:57.56,0:19:59.22,Default,,0,0,0,,magic bits operations,
Dialogue: 0,0:19:59.22,0:20:01.34,Default,,0,0,0,,and the calculates behind the Newton's Method.
Dialogue: 0,0:00:00.00,0:00:05.88,Chinese,,0,0,0,,2005年，id公司发布了《雷神之锤III：竞技场》的源代码
Dialogue: 0,0:00:00.00,0:00:05.88,Comments,,0,0,0,,{\c&H00FFFF&\pos(960,40)}听写+翻译：SuperBart  原作者Nemean发布于2020-11-29\N字幕下载：https://github.com/BenderBolg/Subtitles\N该段源代码在 q_math.c 文件里，根据使用改进引擎情况而定
Dialogue: 0,0:00:05.88,0:00:11.82,Chinese,,0,0,0,,在源代码中，游戏粉丝们找到了一个算法，十分巧妙，很快出名了
Dialogue: 0,0:00:11.82,0:00:16.05,Chinese,,0,0,0,,该算法的唯一用途是计算平方根的倒数
Dialogue: 0,0:00:17.08,0:00:22.25,Chinese,,0,0,0,,要我写计算平方根倒数的代码的话，我会这么写
Dialogue: 0,0:00:22.68,0:00:27.68,Chinese,,0,0,0,,此处我用C语言，和《雷神之锤III》的编程语言相同
Dialogue: 0,0:00:27.68,0:00:31.25,Chinese,,0,0,0,,不过说真的，我没有自行实现开平方根的算法
Dialogue: 0,0:00:31.80,0:00:35.20,Chinese,,0,0,0,,那些对C语言底层和CPU设计更熟悉的人们
Dialogue: 0,0:00:35.20,0:00:37.77,Chinese,,0,0,0,,已经解决了如何用电脑计算平方根的问题了
Dialogue: 0,0:00:35.20,0:00:41.02,Comments,,0,0,0,,SuperBart：网上说现在计算平方根是直接调用CPU的浮点运算单元\N我翻了GCC版的头文件，<math.h>现在只有一堆宏，<mathcalls.h>的具体实现看不懂
Dialogue: 0,0:00:37.77,0:00:41.02,Chinese,,0,0,0,,并且将该算法写进了<math.h>头文件
Dialogue: 0,0:00:41.02,0:00:44.08,Chinese,,0,0,0,,我们程序员直接将该头文件包含进程序就行了
Dialogue: 0,0:00:44.71,0:00:48.74,Chinese,,0,0,0,,那么，怎么《雷神之锤III》的算法就很有趣了呢？
Dialogue: 0,0:00:48.74,0:00:51.71,Chinese,,0,0,0,,当时id公司是怎么计算平方根倒数的呢？
Dialogue: 0,0:00:55.88,0:00:58.74,Chinese,,0,0,0,,乍看上去，完全解释不通啊
Dialogue: 0,0:00:58.74,0:01:03.62,Chinese,,0,0,0,,这个奇怪的 0x5f3759df 怎么冒出来的？
Dialogue: 0,0:01:03.62,0:01:06.65,Chinese,,0,0,0,,算平方根的时候，这步有什么用途？
Dialogue: 0,0:01:06.65,0:01:10.20,Chinese,,0,0,0,,为啥注释者在第二个注释那里极致享受了一下？
Dialogue: 0,0:01:10.20,0:01:12.31,Chinese,,0,0,0,,在这期视频，我将会向你展示
Dialogue: 0,0:01:12.31,0:01:15.85,Chinese,,0,0,0,,计算平方根时候使用到的一些很厉害的位操作
Dialogue: 0,0:01:15.85,0:01:20.31,Chinese,,0,0,0,,以及使用该方法的算法，名称叫平方根倒数速算法
Dialogue: 0,0:01:23.28,0:01:28.20,Chinese,,0,0,0,,首先，为啥游戏引擎要计算平方根的倒数呢？
Dialogue: 0,0:01:28.20,0:01:32.05,Chinese,,0,0,0,,要在游戏引擎内实现物理效果，光影效果，反射效果的话
Dialogue: 0,0:01:32.05,0:01:36.20,Chinese,,0,0,0,,要对使用向量进行单位化，因而我们需要计算平方根倒数
Dialogue: 0,0:01:38.05,0:01:41.17,Chinese,,0,0,0,,要不然的话，向量会过短或过长
Dialogue: 0,0:01:41.17,0:01:43.74,Chinese,,0,0,0,,若在此基础上处理物理效果的话，会出错的
Dialogue: 0,0:01:47.31,0:01:52.62,Chinese,,0,0,0,,众所周知，向量长度是x^2+y^2+z^2的平方根
Dialogue: 0,0:01:53.17,0:01:56.94,Chinese,,0,0,0,,如果你没反应过来的话，我保证你在二维空间里看到过类似的
Dialogue: 0,0:01:56.94,0:01:58.82,Chinese,,0,0,0,,就是勾股定理啊
Dialogue: 0,0:01:59.40,0:02:02.28,Chinese,,0,0,0,,所以，如果你要将向量单位化(把向量长度缩放为1)的话
Dialogue: 0,0:02:02.28,0:02:05.08,Chinese,,0,0,0,,我们要将向量的三个维度都按照模长缩放长度
Dialogue: 0,0:02:05.37,0:02:11.94,Chinese,,0,0,0,,显然，如果我们将向量模长除以向量模长，结果显然为1
Dialogue: 0,0:02:12.42,0:02:16.17,Chinese,,0,0,0,,那么，剩下的事情是将x,y,z轴的长度除以向量模长
Dialogue: 0,0:02:16.17,0:02:20.20,Chinese,,0,0,0,,或者类似地，乘以向量模长的倒数
Dialogue: 0,0:02:20.20,0:02:22.28,Chinese,,0,0,0,,你大概看明白了这其中的问题所在了吧
Dialogue: 0,0:02:25.28,0:02:31.37,Chinese,,0,0,0,,计算x^2+y^2+z^2很简单，更重要的是，真的很快
Dialogue: 0,0:02:31.37,0:02:36.00,Chinese,,0,0,0,,写代码时，你可以这么写: x*x+y*y+z*z.
Dialogue: 0,0:02:36.00,0:02:39.02,Chinese,,0,0,0,,就是三个乘法相加啊
Dialogue: 0,0:02:39.85,0:02:45.20,Chinese,,0,0,0,,加法和乘法是计算机中的基本操作，而且被设计得十分快
Dialogue: 0,0:02:45.94,0:02:49.28,Chinese,,0,0,0,,然而平方根计算却是十分的慢
Dialogue: 0,0:02:49.28,0:02:51.00,Chinese,,0,0,0,,除法计算也快不了哪里去
Dialogue: 0,0:02:51.42,0:02:57.48,Chinese,,0,0,0,,我们要处理上千的平面，每个向量都要单位化的话，这根本不行啊
Dialogue: 0,0:02:58.05,0:03:03.02,Chinese,,0,0,0,,但这也意味着，我们有机会可以提高该算法的速度
Dialogue: 0,0:03:03.02,0:03:07.68,Chinese,,0,0,0,,退一步讲，如果我们可以找到x的平方根倒数的近似结果
Dialogue: 0,0:03:07.68,0:03:11.42,Chinese,,0,0,0,,只要算法很快，我们就能节省很多的时间
Dialogue: 0,0:03:11.42,0:03:14.80,Chinese,,0,0,0,,平方根倒数速算法算的就是近似值
Dialogue: 0,0:03:14.80,0:03:19.65,Chinese,,0,0,0,,大约有1%的误差，不过速度是刚才那个的三倍
Dialogue: 0,0:03:22.02,0:03:26.45,Chinese,,0,0,0,,再次查看代码，我们可以看到，代码开头基本没啥用
Dialogue: 0,0:03:26.45,0:03:29.65,Chinese,,0,0,0,,我们有一个形参'number'作为输入值
Dialogue: 0,0:03:29.65,0:03:32.51,Chinese,,0,0,0,,我们要计算这个数的平方根倒数
Dialogue: 0,0:03:33.05,0:03:36.77,Chinese,,0,0,0,,首先是一个32位整型变量i
Dialogue: 0,0:03:37.62,0:03:42.31,Chinese,,0,0,0,,然后，我们声明两个32位的小数(浮点数)，x2和y
Dialogue: 0,0:03:42.77,0:03:47.51,Chinese,,0,0,0,,然后我们将1.5这个数存入一个常量，名称显然对应该数值
Dialogue: 0,0:03:42.77,0:03:47.51,Comments,,0,0,0,,注：threehalfs指“二分之三”
Dialogue: 0,0:03:48.88,0:03:52.54,Chinese,,0,0,0,,下一行只是很简单地将形参的数值除以2后，存入x2
Dialogue: 0,0:03:52.54,0:03:54.25,Chinese,,0,0,0,,完整的形参则放入y
Dialogue: 0,0:03:54.25,0:03:56.74,Chinese,,0,0,0,,在此之后，魔法就发生了
Dialogue: 0,0:03:57.25,0:03:59.05,Chinese,,0,0,0,,再看一下代码
Dialogue: 0,0:04:01.80,0:04:05.37,Chinese,,0,0,0,,好吧，你看这个代码时间越长，这代码越解释不通
Dialogue: 0,0:04:05.37,0:04:08.02,Chinese,,0,0,0,,而代码右面的注释也帮不上什么忙:-P
Dialogue: 0,0:04:08.65,0:04:12.17,Chinese,,0,0,0,,但是这至少提醒了我们，这个算法有三步
Dialogue: 0,0:04:12.17,0:04:16.74,Chinese,,0,0,0,,将这三步搞明白，算法就能向我们展示出它的巧妙了
Dialogue: 0,0:04:18.20,0:04:22.94,Chinese,,0,0,0,,在开始这三步之前，我们先来了解一下二进制数字
Dialogue: 0,0:04:22.94,0:04:26.40,Chinese,,0,0,0,,代码第一行，我们声明了一个32位的整型变量
Dialogue: 0,0:04:26.40,0:04:29.31,Chinese,,0,0,0,,在C语言中，这被成为'long'
Dialogue: 0,0:04:29.31,0:04:33.54,Chinese,,0,0,0,,也就是说，我们有32个二进制位，我们可以利用这些位表示数字
Dialogue: 0,0:04:33.54,0:04:36.05,Chinese,,0,0,0,,但我觉得，你们肯定知道该如何表示吧
Dialogue: 0,0:04:36.05,0:04:41.00,Chinese,,0,0,0,,这是1,2,3,4,以此类推，大约能到几十亿吧
Dialogue: 0,0:04:36.05,0:04:41.00,Comments,,0,0,0,,{\c&H00FFFF&\pos(960,22.5)}注：2^32 = 42,9496,7296 2^31=21,4748,3648
Dialogue: 0,0:04:41.91,0:04:46.85,Chinese,,0,0,0,,而在下一行，我们声明了两个小数，在C中，被称为'float'
Dialogue: 0,0:04:41.91,0:04:46.85,Comments,,0,0,0,,注：也就是单精度浮点数
Dialogue: 0,0:04:46.85,0:04:51.82,Chinese,,0,0,0,,当然，我们也要用32个二进制位表示小数
Dialogue: 0,0:04:52.28,0:04:53.60,Chinese,,0,0,0,,你会怎么表示呢？
Dialogue: 0,0:04:54.05,0:04:58.68,Chinese,,0,0,0,,如果咱们一起设计小数的话，也许这是我们的设计方案之一
Dialogue: 0,0:04:59.17,0:05:01.08,Chinese,,0,0,0,,直接在中间放小数点就行了啊
Dialogue: 0,0:05:01.54,0:05:04.60,Chinese,,0,0,0,,在小数点之前，我们按照一般方法数出整数部分
Dialogue: 0,0:05:04.60,0:05:07.42,Chinese,,0,0,0,,1,2,3,4……以此类推
Dialogue: 0,0:05:07.42,0:05:10.68,Chinese,,0,0,0,,而在小数部分之后，不出所料，也是这样
Dialogue: 0,0:05:11.02,0:05:16.02,Chinese,,0,0,0,,不过呢，这可是二进制，所以，我们不数十分位、百分位、千分位
Dialogue: 0,0:05:16.02,0:05:17.94,Chinese,,0,0,0,,我们数二分之一，四分之一，八分之一
Dialogue: 0,0:05:17.94,0:05:20.48,Chinese,,0,0,0,,十六分之一，以及其所有的组合
Dialogue: 0,0:05:20.48,0:05:25.22,Chinese,,0,0,0,,比如，二分之一加四分之一等于四分之三，也就是0.75
Dialogue: 0,0:05:26.37,0:05:28.60,Chinese,,0,0,0,,但这个想法实际上很糟糕
Dialogue: 0,0:05:28.60,0:05:31.77,Chinese,,0,0,0,,我们大幅缩小了这些位数可以表示的数字
Dialogue: 0,0:05:31.77,0:05:35.51,Chinese,,0,0,0,,之前我们可以表示大约20亿的数字
Dialogue: 0,0:05:35.51,0:05:38.25,Chinese,,0,0,0,,现在只有3万2千左右了
Dialogue: 0,0:05:35.51,0:05:38.25,Comments,,0,0,0,,注：2^16=65536 2^15=32768
Dialogue: 0,0:05:39.00,0:05:44.05,Chinese,,0,0,0,,幸亏，那些比我们聪明的人们想出个更好的方法来充分利用这32位
Dialogue: 0,0:05:44.57,0:05:47.65,Chinese,,0,0,0,,他们是从科学记数法中获得的灵感
Dialogue: 0,0:05:48.77,0:05:51.57,Chinese,,0,0,0,,这样，我们就能系统地表示数字了
Dialogue: 0,0:05:51.57,0:05:55.02,Chinese,,0,0,0,,诸如23000=2.3*10^4
Dialogue: 0,0:05:55.02,0:05:59.45,Chinese,,0,0,0,,0.0034=3.4*10^-3
Dialogue: 0,0:05:59.85,0:06:02.48,Chinese,,0,0,0,,在二进制体系中，我们也可以这么表示小数
Dialogue: 0,0:06:02.48,0:06:09.05,Chinese,,0,0,0,,举例，二进制数11000可以用1.1*2^4表示
Dialogue: 0,0:06:10.54,0:06:15.48,Chinese,,0,0,0,,规定此表示方式的标准称为 IEEE 754
Dialogue: 0,0:06:17.48,0:06:21.02,Chinese,,0,0,0,,IEEE 754 标准规定如下：
Dialogue: 0,0:06:21.32,0:06:23.77,Chinese,,0,0,0,,和之前一样，我们有32位
Dialogue: 0,0:06:24.25,0:06:26.27,Chinese,,0,0,0,,第一位是正负号位
Dialogue: 0,0:06:26.27,0:06:28.35,Chinese,,0,0,0,,如果该位是0，则该数为正数
Dialogue: 0,0:06:28.35,0:06:30.35,Chinese,,0,0,0,,如果该位是1，则该数为负数
Dialogue: 0,0:06:30.87,0:06:35.52,Chinese,,0,0,0,,但是在游戏中，传给快速平方根倒数函数的值一定是正的
Dialogue: 0,0:06:35.90,0:06:37.80,Chinese,,0,0,0,,不用想，这些数绝对是正的啊
Dialogue: 0,0:06:37.80,0:06:43.17,Chinese,,0,0,0,,我们要算-5的平方根倒数的话，绝对会出现不好的事情:-P
Dialogue: 0,0:06:43.77,0:06:48.27,Chinese,,0,0,0,,所以对于视频的剩余部分，我们不考虑正负号位，默认其为0
Dialogue: 0,0:06:49.90,0:06:53.05,Chinese,,0,0,0,,然后，接下来的8位决定指数部分
Dialogue: 0,0:06:53.05,0:06:58.15,Chinese,,0,0,0,,也就是2的1次方，2次方，3次方，4次方，以此类推
Dialogue: 0,0:06:58.15,0:07:02.35,Chinese,,0,0,0,,我们可以利用这8位，表示介于0和255之间的数
Dialogue: 0,0:06:58.15,0:07:02.35,Comments,,0,0,0,,注：2^8=256 2^7=128 想记住的话，建议玩2048去
Dialogue: 0,0:07:03.20,0:07:07.27,Chinese,,0,0,0,,但这个仍不是我们想要的，我们还想要负指数
Dialogue: 0,0:07:08.20,0:07:12.07,Chinese,,0,0,0,,这就是为什么这里出现的数用的时候，得减去127
Dialogue: 0,0:07:13.25,0:07:17.75,Chinese,,0,0,0,,所以说，我们实际得到的是2^(4-127)，而不是2^4
Dialogue: 0,0:07:18.45,0:07:23.07,Chinese,,0,0,0,,如果我们需要的指数必须是4的话，这里必须要被设为131
Dialogue: 0,0:07:23.60,0:07:28.17,Chinese,,0,0,0,,因为 131-127=4
Dialogue: 0,0:07:29.82,0:07:32.50,Chinese,,0,0,0,,剩下的23位表示尾数
Dialogue: 0,0:07:33.07,0:07:37.32,Chinese,,0,0,0,,在科学记数法中，我们要先表示一位整数部分
Dialogue: 0,0:07:37.32,0:07:40.55,Chinese,,0,0,0,,然后是小数点，以及之后的小数部分
Dialogue: 0,0:07:41.07,0:07:47.37,Chinese,,0,0,0,,利用这23位，我们能表示从0到2^23(不包括此数)之间的任意一数
Dialogue: 0,0:07:48.00,0:07:50.40,Chinese,,0,0,0,,当然，这还不是我们想要的
Dialogue: 0,0:07:50.75,0:07:54.82,Chinese,,0,0,0,,对于十进制科学记数法，我们需要尾数的表示范围在1到10之间
Dialogue: 0,0:07:54.82,0:07:58.50,Chinese,,0,0,0,,而在二进制科学记数法中，则是1到2之间
Dialogue: 0,0:08:00.15,0:08:03.20,Chinese,,0,0,0,,现在我们可以做一些之前就想做的事情了
Dialogue: 0,0:08:03.20,0:08:05.37,Chinese,,0,0,0,,在第一位的后面加小数点
Dialogue: 0,0:08:05.37,0:08:08.35,Chinese,,0,0,0,,这将会自动地使尾数的范围在1和2之间
Dialogue: 0,0:08:09.17,0:08:11.25,Chinese,,0,0,0,,但如此朴素的想法是对位数的浪费
Dialogue: 0,0:08:11.62,0:08:15.32,Chinese,,0,0,0,,你看啊，那些设计754标准的人们意识到
Dialogue: 0,0:08:15.32,0:08:19.47,Chinese,,0,0,0,,在二进制里，会出现一些在其他进制系统里不可能发生的事情
Dialogue: 0,0:08:23.97,0:08:25.50,Chinese,,0,0,0,,看一下第一位
Dialogue: 0,0:08:26.02,0:08:31.00,Chinese,,0,0,0,,在科学记数法中，第一位按照定义，一定不是0
Dialogue: 0,0:08:31.45,0:08:36.00,Chinese,,0,0,0,,而在二进制中，只有一个数是非零数，它就是1
Dialogue: 0,0:08:36.65,0:08:41.42,Chinese,,0,0,0,,要是第一位永远是1的话，我们就没有必要存储它了
Dialogue: 0,0:08:41.85,0:08:46.40,Chinese,,0,0,0,,这样，我们节省了一位的存储空间，直接把小数点移动到左面
Dialogue: 0,0:08:46.40,0:08:49.45,Chinese,,0,0,0,,然后在回来转换的时候，整数部分改成1即可
Dialogue: 0,0:08:49.77,0:08:52.45,Chinese,,0,0,0,,现在尾数的表示区间是在1和2之间了
Dialogue: 0,0:08:53.25,0:08:57.80,Chinese,,0,0,0,,尽管23位能够表示0到2^23之间的数
Dialogue: 0,0:08:57.80,0:09:01.22,Chinese,,0,0,0,,我们将表示数字的范围缩小到0和1之间
Dialogue: 0,0:09:01.22,0:09:05.20,Chinese,,0,0,0,,然后我们再补一个1，就让其范围为1到2之间
Dialogue: 0,0:09:06.87,0:09:11.55,Chinese,,0,0,0,,这就是 IEEE 754 标准的主要内容了
Dialogue: 0,0:09:11.55,0:09:14.35,Chinese,,0,0,0,,不过呢，刚才说的都是“规格化数”
Dialogue: 0,0:09:14.70,0:09:22.92,Chinese,,0,0,0,,懂得多的人知道，这个标准还有非规格化数，非数，无穷和两个零
Dialogue: 0,0:09:14.70,0:09:22.92,Comments,,0,0,0,,注：两个零指的是+0和-0
Dialogue: 0,0:09:23.16,0:09:24.53,Chinese,,0,0,0,,这里我们不会涉猎
Dialogue: 0,0:09:24.68,0:09:29.09,Chinese,,0,0,0,,因为在《雷神之锤III》里，这些数恰巧是不会输入进算法的
Dialogue: 0,0:09:29.50,0:09:32.56,Chinese,,0,0,0,,要不然，绝对会有事情出错的
Dialogue: 0,0:09:32.85,0:09:37.25,Chinese,,0,0,0,,根本没必要让游戏引擎单位化无限长的向量:-P
Dialogue: 0,0:09:38.44,0:09:40.93,Chinese,,0,0,0,,对于本算法，以及视频的剩下部分
Dialogue: 0,0:09:40.93,0:09:45.72,Chinese,,0,0,0,,思考尾数，指数和二进制数字之间的关系十分有用
Dialogue: 0,0:09:46.17,0:09:50.66,Chinese,,0,0,0,,我们有两个数，一个是尾数，一个是指数
Dialogue: 0,0:09:50.66,0:09:53.17,Chinese,,0,0,0,,分别用23个二进制位和8个二进制位表示
Dialogue: 0,0:09:53.17,0:09:55.18,Chinese,,0,0,0,,我们可以利用这些位数表示他们
Dialogue: 0,0:09:55.44,0:09:58.97,Chinese,,0,0,0,,仔细想的话，是2^23乘以指数E，再加上尾数M
Dialogue: 0,0:09:59.68,0:10:05.02,Chinese,,0,0,0,,因为将指数E乘以2^23，相当于将其进23个二进制位
Dialogue: 0,0:10:06.21,0:10:08.24,Chinese,,0,0,0,,所以，我们可以用这些二进制位表示浮点数了
Dialogue: 0,0:10:08.56,0:10:12.21,Chinese,,0,0,0,,我们可以用这个公式算数这些位数表示的实际数字
Dialogue: 0,0:10:12.94,0:10:14.69,Chinese,,0,0,0,,你应该很熟悉这个公式了
Dialogue: 0,0:10:12.94,0:10:14.69,Comments,,0,0,0,,SuperBart：除非你退出视频，或者上政治课睡着了/滑稽
Dialogue: 0,0:10:15.01,0:10:19.14,Chinese,,0,0,0,,这里，我们的指数被减去了127
Dialogue: 0,0:10:19.36,0:10:22.61,Chinese,,0,0,0,,我们的尾数前面也多了一个1
Dialogue: 0,0:10:24.13,0:10:26.24,Chinese,,0,0,0,,不过，现在的事情有点不同了
Dialogue: 0,0:10:26.72,0:10:31.04,Chinese,,0,0,0,,这里，我们将完全没有缘由地对该公式取对数
Dialogue: 0,0:10:31.57,0:10:35.61,Chinese,,0,0,0,,既然我们干的是计科的事情，我们对数的底数取为2
Dialogue: 0,0:10:36.12,0:10:38.28,Chinese,,0,0,0,,我们这里尽量简化
Dialogue: 0,0:10:38.57,0:10:39.78,Chinese,,0,0,0,,将指数取出
Dialogue: 0,0:10:40.01,0:10:41.13,Chinese,,0,0,0,,然后，我们卡住了:-(
Dialogue: 0,0:10:41.98,0:10:44.05,Chinese,,0,0,0,,然而《雷神之锤》的开发者并没有
Dialogue: 0,0:10:44.36,0:10:47.88,Chinese,,0,0,0,,开发者 Gary Tarolli 知道去掉(简化)对数的技巧
Dialogue: 0,0:10:44.36,0:10:47.88,Comments,,0,0,0,,注：就现在所知，平方根倒数速算法最早由Gary Tarolli在SGI Indigo的开发中使用
Dialogue: 0,0:10:48.65,0:10:52.74,Chinese,,0,0,0,,技巧就是log(1+x)的极限
Dialogue: 0,0:10:53.06,0:10:58.40,Chinese,,0,0,0,,对于很小的x，log(1+x)大致相当于x
Dialogue: 0,0:10:58.85,0:11:02.09,Chinese,,0,0,0,,仔细想的话，这个近似实际上是正确的
Dialogue: 0,0:10:58.85,0:11:02.09,Comments,,0,0,0,,{\c&H00FFFF&\pos(960,23)}注：已知ln(1+x)~x，又loga(1+x)=ln(1+x)/lna，所以.......
Dialogue: 0,0:11:02.28,0:11:05.02,Chinese,,0,0,0,,如果x=0，然后x=1的话，(就和原函数的对应因变量完全相同)
Dialogue: 0,0:11:05.76,0:11:08.18,Chinese,,0,0,0,,但如果我们再加入一个校正系数，称为μ
Dialogue: 0,0:11:08.76,0:11:11.13,Chinese,,0,0,0,,该校正系数可任意选择
Dialogue: 0,0:11:11.53,0:11:16.36,Chinese,,0,0,0,,若校正系数μ为0，该近似函数将于0和1处与原函数所得因变量相同
Dialogue: 0,0:11:16.62,0:11:19.26,Chinese,,0,0,0,,不过最终得出结论，将校正系数μ设为该值
Dialogue: 0,0:11:19.26,0:11:23.34,Chinese,,0,0,0,,在0到1的范围内，总体偏差最小
Dialogue: 0,0:11:24.86,0:11:27.84,Chinese,,0,0,0,,回到公式，我们利用这个技巧
Dialogue: 0,0:11:27.84,0:11:32.84,Chinese,,0,0,0,,由于M已经被2^23除去，它一定是0到1之间的数
Dialogue: 0,0:11:34.14,0:11:39.41,Chinese,,0,0,0,,再稍微整理一下，我们终于知道为啥我们要如此计算了
Dialogue: 0,0:11:40.26,0:11:43.26,Chinese,,0,0,0,,指数E乘以2的23次方，再加上尾数M
Dialogue: 0,0:11:43.72,0:11:45.54,Chinese,,0,0,0,,这就是浮点数的二进制表示嘛
Dialogue: 0,0:11:46.62,0:11:49.02,Chinese,,0,0,0,,接下来，我们再想想我们之前干了啥
Dialogue: 0,0:11:49.42,0:11:53.88,Chinese,,0,0,0,,我们把公式取了对数，得到了二进制表示的形式
Dialogue: 0,0:11:53.88,0:11:56.29,Chinese,,0,0,0,,仅仅是缩放了一下，移动了几位
Dialogue: 0,0:11:56.77,0:12:01.02,Chinese,,0,0,0,,在某种意义上，浮点数的二进制表示的就是它的对数形式
Dialogue: 0,0:12:01.58,0:12:07.09,Chinese,,0,0,0,,懂了这么多，我们终于可以开始了解快速平方根倒数算法的三部曲了
Dialogue: 0,0:12:16.65,0:12:18.96,Chinese,,0,0,0,,第一步实际上并不复杂
Dialogue: 0,0:12:18.96,0:12:22.09,Chinese,,0,0,0,,看起来很复杂，是因为对这行代码是在内存地址方面做了些手脚
Dialogue: 0,0:12:22.64,0:12:27.21,Chinese,,0,0,0,,我们将数字存入y，然后我们想做些很厉害的位操作
Dialogue: 0,0:12:27.60,0:12:32.10,Chinese,,0,0,0,,然而呢，浮点数没有做位操作的方法
Dialogue: 0,0:12:32.72,0:12:37.48,Chinese,,0,0,0,,为啥浮点数不能做位操作呢，因为它根本就不是为位操作设计的啊
Dialogue: 0,0:12:38.00,0:12:41.82,Chinese,,0,0,0,,浮点数本质上严格遵守IEEE 754标准
Dialogue: 0,0:12:42.42,0:12:46.21,Chinese,,0,0,0,,然而，长整型数可以用来做位操作
Dialogue: 0,0:12:46.66,0:12:48.10,Chinese,,0,0,0,,此处用一个小技巧举例
Dialogue: 0,0:12:51.42,0:12:53.80,Chinese,,0,0,0,,向左位平移能将这个数加倍
Dialogue: 0,0:12:55.89,0:12:58.18,Chinese,,0,0,0,,向右位平移能将这个数减半
Dialogue: 0,0:12:59.18,0:13:02.65,Chinese,,0,0,0,,当然，如果是个奇数的话，最终会有舍去
Dialogue: 0,0:12:59.18,0:13:02.65,Comments,,0,0,0,,SuperBart：抱歉各位，odd(奇数)和even(偶数)搞反了……
Dialogue: 0,0:13:05.34,0:13:10.72,Chinese,,0,0,0,,不过呢，我们可以接受这点不准确，只要这个算法够快就好
Dialogue: 0,0:13:12.38,0:13:15.12,Chinese,,0,0,0,,像其他的编程语言一样，C语言提供了一种方法
Dialogue: 0,0:13:15.12,0:13:18.29,Chinese,,0,0,0,,能将浮点数转换为长整型数
Dialogue: 0,0:13:18.76,0:13:21.66,Chinese,,0,0,0,,这种转换能满足程序员的大部分需要
Dialogue: 0,0:13:21.66,0:13:26.28,Chinese,,0,0,0,,就是将一个小数(浮点数)尽力转换为一个整型数
Dialogue: 0,0:13:26.72,0:13:32.53,Chinese,,0,0,0,,如果浮点数是3.33的话，它能将其转换成整型数，也就是3
Dialogue: 0,0:13:33.04,0:13:35.33,Chinese,,0,0,0,,不过这个转换不是我们想要的
Dialogue: 0,0:13:35.70,0:13:39.14,Chinese,,0,0,0,,首先，我们对转换后的整型结果不感兴趣
Dialogue: 0,0:13:39.14,0:13:41.40,Chinese,,0,0,0,,我们想让其保持浮点数的形式
Dialogue: 0,0:13:41.86,0:13:45.37,Chinese,,0,0,0,,其次，浮点数背后的那堆二进制数也都被打乱了
Dialogue: 0,0:13:45.92,0:13:48.52,Chinese,,0,0,0,,我们不希望转换对二进制位有任何影响
Dialogue: 0,0:13:49.00,0:13:53.76,Chinese,,0,0,0,,我们想要的是，逐位将其转换到长整型形式
Dialogue: 0,0:13:56.94,0:14:01.28,Chinese,,0,0,0,,你要这么干的话，就要转换该数对应的内存地址，而不是数字本身
Dialogue: 0,0:14:02.90,0:14:07.24,Chinese,,0,0,0,,首先，我们得到了浮点数y的地址，这个是一个float类型的地址
Dialogue: 0,0:14:07.90,0:14:12.16,Chinese,,0,0,0,,然后我们将该地址转换成long(长整型)类型的地址
Dialogue: 0,0:14:13.36,0:14:19.40,Chinese,,0,0,0,,地址本身没变，但是C语言认为该地址内的数是个长整型了
Dialogue: 0,0:14:20.00,0:14:22.80,Chinese,,0,0,0,,然后就该读取该地址内的数字了
Dialogue: 0,0:14:23.00,0:14:25.90,Chinese,,0,0,0,,由于现在C语言认为该地址的类型是long
Dialogue: 0,0:14:25.90,0:14:29.69,Chinese,,0,0,0,,它将按照长整型类型读取该地址里的数字
Dialogue: 0,0:14:30.42,0:14:34.86,Chinese,,0,0,0,,像这样，我们避开数字本身，利用该数所在的地址
Dialogue: 0,0:14:34.86,0:14:36.86,Chinese,,0,0,0,,运用了C语言的一些手段实现目的
Dialogue: 0,0:14:37.86,0:14:40.76,Chinese,,0,0,0,,这样该浮点数的二进制表示存入了i
Dialogue: 0,0:14:41.28,0:14:44.24,Chinese,,0,0,0,,没啥可说的，C语言就是这样工作的啊
Dialogue: 0,0:14:44.24,0:14:45.90,Chinese,,0,0,0,,我们直接进入下一步
Dialogue: 0,0:14:51.84,0:14:54.78,Chinese,,0,0,0,,算法的第二步有一点很显然
Dialogue: 0,0:14:55.18,0:14:58.53,Chinese,,0,0,0,,还记得吗，向左位平移能将这个数加倍
Dialogue: 0,0:15:00.33,0:15:02.44,Chinese,,0,0,0,,向右位平移能将这个数减半
Dialogue: 0,0:15:03.45,0:15:06.73,Chinese,,0,0,0,,但要对于指数进行该变换，会发生什么呢
Dialogue: 0,0:15:07.54,0:15:10.06,Chinese,,0,0,0,,指数加倍，相当于对该数平方
Dialogue: 0,0:15:10.06,0:15:12.84,Chinese,,0,0,0,,指数减半，相当于对该数进行开方
Dialogue: 0,0:15:13.24,0:15:17.85,Chinese,,0,0,0,,现在对指数取负，就是将x开方后取倒数
Dialogue: 0,0:15:17.85,0:15:19.34,Chinese,,0,0,0,,这正是我们想要的
Dialogue: 0,0:15:20.53,0:15:23.01,Chinese,,0,0,0,,所以，我们要明白我们的目标就是这个
Dialogue: 0,0:15:23.33,0:15:25.24,Chinese,,0,0,0,,我们的数字存于y
Dialogue: 0,0:15:25.24,0:15:28.52,Chinese,,0,0,0,,我们的目标就是计算y的平方根倒数
Dialogue: 0,0:15:28.92,0:15:33.32,Chinese,,0,0,0,,之前提到，直接计算相当困难，耗时很久
Dialogue: 0,0:15:34.00,0:15:36.00,Chinese,,0,0,0,,但是我们已经提取出y的二进制位表示
Dialogue: 0,0:15:36.00,0:15:39.18,Chinese,,0,0,0,,我们也知道按照IEEE 754标准
Dialogue: 0,0:15:39.18,0:15:42.73,Chinese,,0,0,0,,浮点数的二进制表示在某种意义上，就是该二进制数的对数
Dialogue: 0,0:15:43.40,0:15:48.33,Chinese,,0,0,0,,也就是说，在i里，我们存有y的对数，当然还有一些放缩和变换
Dialogue: 0,0:15:49.00,0:15:53.01,Chinese,,0,0,0,,我觉得要是处理对数的话，问题会变得简单
Dialogue: 0,0:15:53.60,0:15:57.37,Chinese,,0,0,0,,与其花很多力气直接计算y的平方根倒数
Dialogue: 0,0:15:57.37,0:16:00.89,Chinese,,0,0,0,,我们直接计算y平方根倒数的对数
Dialogue: 0,0:16:01.68,0:16:05.13,Chinese,,0,0,0,,这里重新写成y的负二分之一次方的对数
Dialogue: 0,0:16:05.13,0:16:07.00,Chinese,,0,0,0,,这样指数可以提到前面
Dialogue: 0,0:16:07.64,0:16:10.26,Chinese,,0,0,0,,算这个可就简单多了
Dialogue: 0,0:16:10.64,0:16:16.01,Chinese,,0,0,0,,你也许会想:"天哪，这里可有除法。刚开始不是说除法很慢的吗?"
Dialogue: 0,0:16:16.41,0:16:19.45,Chinese,,0,0,0,,没错，不过这里我们可以进行位平移了
Dialogue: 0,0:16:19.88,0:16:23.40,Chinese,,0,0,0,,我们不算除以2，我们直接将其向右平移一位
Dialogue: 0,0:16:23.85,0:16:28.36,Chinese,,0,0,0,,这就解释了为啥我们要算i的负数，并将i向右移动一位
Dialogue: 0,0:16:29.08,0:16:33.25,Chinese,,0,0,0,,不过，0x5f3759df这个数在这里有啥用啊?
Dialogue: 0,0:16:33.69,0:16:37.21,Chinese,,0,0,0,,根据公式，我们还要放缩和位平移
Dialogue: 0,0:16:37.48,0:16:40.41,Chinese,,0,0,0,,我们来算一下这个数是从哪里来的
Dialogue: 0,0:16:41.00,0:16:48.41,Chinese,,0,0,0,,设Γ为解，则解Γ和y对数的负二分之一方相同
Dialogue: 0,0:16:48.80,0:16:51.44,Chinese,,0,0,0,,也就是y的对数乘以负二分之一
Dialogue: 0,0:16:52.12,0:16:55.72,Chinese,,0,0,0,,现在，我们将该对数用二进制位来表示
Dialogue: 0,0:17:01.94,0:17:04.38,Chinese,,0,0,0,,接下来，我们仅需算出解Γ的二进制位表示
Dialogue: 0,0:17:04.82,0:17:07.53,Chinese,,0,0,0,,此处略去细节，结果如下
Dialogue: 0,0:17:09.33,0:17:12.88,Chinese,,0,0,0,,那个魔力数字，原来是按照校正系数μ
Dialogue: 0,0:17:12.88,0:17:14.88,Chinese,,0,0,0,,放缩系数和平移系数来纠正误差的
Dialogue: 0,0:17:16.81,0:17:19.45,Chinese,,0,0,0,,现在我们有结果的位表示了
Dialogue: 0,0:17:19.45,0:17:25.26,Chinese,,0,0,0,,我们仅需再按照邪恶的位操作，将二进制位转换回浮点数结果即可
Dialogue: 0,0:17:25.81,0:17:30.20,Chinese,,0,0,0,,实际上，这不是确切结果，仅仅是一个近似值
Dialogue: 0,0:17:30.53,0:17:32.90,Chinese,,0,0,0,,这就是为啥我们需要第三步了
Dialogue: 0,0:17:41.50,0:17:44.89,Chinese,,0,0,0,,上一步之后，我们得到了一个还可以的的近似值了
Dialogue: 0,0:17:44.89,0:17:47.34,Chinese,,0,0,0,,但我们的结果或多或少有一些误差
Dialogue: 0,0:17:47.86,0:17:52.61,Chinese,,0,0,0,,但按照牛顿迭代法，我们可以把还可以的近似值变成很好的近似值
Dialogue: 0,0:17:53.21,0:17:56.89,Chinese,,0,0,0,,牛顿迭代法是一个用来寻找方程根的方法
Dialogue: 0,0:17:57.09,0:18:00.21,Chinese,,0,0,0,,也就是找到一个x，使f(x)=0
Dialogue: 0,0:18:00.68,0:18:04.89,Chinese,,0,0,0,,它的实现方法是，通过取近似的方式来得到一个更好的近似
Dialogue: 0,0:18:05.09,0:18:09.72,Chinese,,0,0,0,,通常，你可以重复该过程，直到与实际结果十分接近
Dialogue: 0,0:18:09.72,0:18:14.40,Chinese,,0,0,0,,然而实际上，我们已经很接近实际结果了
Dialogue: 0,0:18:14.40,0:18:18.53,Chinese,,0,0,0,,一次迭代得到的结果，会有1%的误差
Dialogue: 0,0:18:21.82,0:18:26.33,Chinese,,0,0,0,,牛顿迭代法仅需两件东西，方程对应函数和函数的导数
Dialogue: 0,0:18:26.33,0:18:29.89,Chinese,,0,0,0,,牛顿迭代法呢，首先取一个x值
Dialogue: 0,0:18:29.89,0:18:38.16,Chinese,,0,0,0,,然后通过计算f(x)以及其导数来估计该值与实际根的偏差
Dialogue: 0,0:18:41.76,0:18:46.80,Chinese,,0,0,0,,我们将f(x)写为y，导数则是dy/dx
Dialogue: 0,0:18:49.88,0:18:54.20,Chinese,,0,0,0,,我们得到了y的偏差和x的偏差，以及y本身
Dialogue: 0,0:18:54.50,0:18:58.29,Chinese,,0,0,0,,要得到x偏差，我们仅需将y除以其导数
Dialogue: 0,0:19:04.22,0:19:07.78,Chinese,,0,0,0,,然后我们减去偏差，得到一个新x
Dialogue: 0,0:19:10.29,0:19:16.24,Chinese,,0,0,0,,某些学霸们现在可意识到最后一行就是按照公式实现的牛顿迭代法
Dialogue: 0,0:19:16.45,0:19:20.22,Chinese,,0,0,0,,{\pos(960,125)}f(y)等于y平方的倒数减去x
Dialogue: 0,0:19:20.84,0:19:27.09,Chinese,,0,0,0,,{\pos(960,125)}注意，作为方程根的y与x的平方根倒数是相同的
Dialogue: 0,0:19:30.93,0:19:34.06,Chinese,,0,0,0,,{\pos(960,125)}我强烈建议大家自行验证该代码的最后一行
Dialogue: 0,0:19:34.06,0:19:42.16,Chinese,,0,0,0,,{\pos(960,125)}因为尽管该公式以及牛顿迭代法本身有除法，但是代码里没有
Dialogue: 0,0:19:42.16,0:19:45.58,Chinese,,0,0,0,,{\pos(960,125)}意味着该算法一直会很很高速地运行
Dialogue: 0,0:19:47.45,0:19:50.54,Chinese,,0,0,0,,现在我们终于搞明白快速平方根倒数算法了
Dialogue: 0,0:19:50.54,0:19:54.73,Chinese,,0,0,0,,仅仅是利用到了了 IEEE 754 标准知识
Dialogue: 0,0:19:54.73,0:19:57.56,Chinese,,0,0,0,,对C语言特性的灵活利用
Dialogue: 0,0:19:57.56,0:19:59.22,Chinese,,0,0,0,,具有魔力的位平移
Dialogue: 0,0:19:59.22,0:20:01.34,Chinese,,0,0,0,,以及牛顿迭代法背后的运算法则
Dialogue: 0,0:20:03.00,0:20:07.72,Comments,,0,0,0,,{\pos(438,272)}注：ioquake改进版中，引入了一个联合\N{\an4}\h\h\h\htypedef union floatint_u \{\N\h\h\h\h\h\h\hint32_t i;\N\h\h\h\h\h\h\huint32_t u;\N\h\h\h\h\h\h\hfloat f;\N\h\h\h\h\h\h\hbyte b[4];\N\h\h\h\h\}floatint_t;\N这样，第一步可以不用更改指针类型了\N不过我很怀疑有多少人会看到这里......
